Goで、Concatnative Stack-Oriented Programming Languageを作る

5 Apr 2019
Tags: go

朝倉
ITS
mk2@mk2.red
https://mk2.red

* 自己紹介
- 朝倉 遼
- 2018/08入社(転職)
- 30歳まで東京
- 実家も東京
- 今は福井

* 今日話すこと
- スタック指向かつ連鎖性言語の話
- Goのlexerの書き方

* スタック指向プログラミング言語とは？

いくつかのプログラミング言語はスタック指向である。スタック指向言語は、基本操作（二つの数の加算、一文字表示など）で *スタックから引数を取ってくるようになっていて、結果をスタックに返す* ようになっている言語である。

たいていは複数のスタックを使うよう設計されており、典型的なForthは、引数受け渡しのためのスタックとサブルーチンのリターンアドレスのためのスタックを持つ。PostScriptはリターンスタックとオペランドスタックを持ち、グラフィックス状態スタックと辞書スタックも持っている。日本語プログラミング言語のMindもForthベースである。

.link https://ja.wikipedia.org/wiki/%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF#%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E6%8C%87%E5%90%91%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9E スタック#スタック指向プログラミング言語

* 要するに

- 超シンプルなプログラミング言語
- プログラマが手で書くことは、（酔狂な暇人を除いて）基本的に無い

* 連鎖性プログラミング言語とは？

- RPN（逆ポーランド記法）で書く
- 有名所はForth

  "Hello world" print
  1 2 + 4 *

- ポイントフリースタイルの一種
- Haskellとかはポイントフリースタイル
- 連鎖性プログラミング言語は、だいたいスタック指向プログラミング言語でもある

* どういうところが魅力なのか？
- プログラミング環境を自作する、という点において、 *Lexer/Parserを書くのが楽*
- データとコードが同じ構造を持つ
- いわゆる同図象性
- メタプロがやりやすい

* 実装していく

.link https://github.com/mk2/yon

3年前にGo1.5で実装。最近またいじり始めたが、特に大きな修正なく動いている。 *後方互換性* バンザイ！

  1 2 3 4 dup [ 1 + dup ] apply

こんな感じのコードを実行可能です。

* プログラミング環境を実装するということ

一般的には、下記のように言語処理系は動く。

  文字列
   ↓ (Lexer、以降トークン変換器)
  トークンの列
   ↓ (Parser、以降ワード変換器)
  プログラムを構成する要素の列
   ↓ (Interpreter、以降解釈器)
  逐次実行処理

Goでやる場合も同じ。

* Lexer/Parserの実装

Rob Pike御大が出している、GoでのLexer実装パターンに則って実装。

.link https://talks.golang.org/2011/lex.slide Lexical Scanning in Go - 30 August 2011, Rob Pike

- Lexerの実装方法は無数にあるが、御大は、ツールや正規表現に頼るよりも自分で書くことを勧めている

* 状態関数

  type stateFn func(*lexer) stateFn

- 状態を関数として表現する
- 関数を評価すると、次の状態（関数）が手に入る

* Goroutineとどう合わせて使うか？

- 状態関をGoroutineとして実行
- トークンが生成できたら、チャンネルに送信する

* サンプル

.code ./code/lexer.go /START LEXER_TYPE OMIT/,/END LEXER_TYPE OMIT/

* サンプル

.code ./code/lexer.go /START NEW_LEXER OMIT/,/END NEW_LEXER OMIT/

.code ./code/lexer.go /START LEXER_RUN OMIT/,/END LEXER_RUN OMIT/

* サンプル

.code ./code/lexer.go /START STATEFN_START OMIT/,/END STATEFN_START OMIT/

.code ./code/lexer.go /START STATEFN_END OMIT/,/END STATEFN_END OMIT/

* Rob Pike法のメリット

他のやり方を書いたことがないので、明確にこれが良い、というのは言えない。
ただ、stateFnのやり方でLexer/Parser両方書けるので、汎用性は高いやり方なんだと思う。

* インタプリタの実装

- やってて一番楽しい部分 
- Lexer/Parserの苦痛はここで報われる

だがしかし、ちょっとここまで書く余裕がありませんでした！
